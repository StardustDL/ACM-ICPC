/*
IncDec Sequence
分析：相邻两项做差，也就是数列的差分，这样就把区间修改问题改为单个元素修改问题。并且做差之后，问题也基本转换成功。
		对于带有“将一段区间内的每个数全部加上某个值”这种操作的题目，通常考虑差分原数列以简化情况，将对一段区间的操作转化为对某两个特定数的操作。
		我们定义d_1 = a_1, d_i = a_i - a_{i-1} ( 2 ≤ i ≤ n ), d_{n+1} = 0（事实上，稍后我们会看到d_1和d_{n+1}的值并不重要），
		可以发现，原题中的“将[l,r]内的数都加一或都减一”将对应“将d_l + 1，将d_{r+1} - 1”（或反之）的操作。
		显然，题目中要求的a数列中的所有数全部相等的条件等同于使d_i = 0 ( 2 ≤ i ≤ n )，最后数列中的数即为d_1，
		而题目中的操作允许我们把d数列中的某个数+1，某个数-1。
		要将d数列中第二项至第n项全部变为0并使操作次数最少，首先我们将每个负数和每个正数配对执行操作，
		设d数列中第2至第n项所有正数分别求和得到的值为p，负数分别求和得到的值的*绝对值*为q，
		这一步的操作次数即为min{p,q}。此时还剩余和的绝对值为abs(p-q)的数没有变为0，
		每次操作我们可以将其与d_1或d_{n+1}配对进行操作，操作次数为abs(p-q)，容易看出，
		最终d_1的可能取值有abs(p-q)+1种。因此，第一问的答案即为max{p,q}，第二问的答案即为abs(p-q)+1。 
*/
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
using namespace std;
typedef long long LL;
LL n,a[2],x,y,z;
int main(){
    cin>>n>>x;
    for(int i=2;i<=n;i++,x=y){
        cin>>y;
        z=y-x;
        a[z>=0]+=abs(z);
    }
    cout<<max(a[0],a[1])<<endl<<abs(a[1]-a[0])+1<<endl;
    return 0;
}

