/*
登山
分析：首先就是对于题意的理解出现了问题，题目表述不清楚，走的四个方向就把我整晕了，左右好理解，左上右上是啥回事，后来才想明白是三角锥形的排列方式，如下图，每行数据还是圆形排列，就像一个圆锥。
	  本题可以采用自上而下或者自下而上两种方式来求解，我们采用自上而下的方式。根据上图的排列我们可构造出动态规划方程
		step[i][j] = min{step[i][j-1]+a[i][j],step[i][j+1]+a[i][j],step[i-1][j-1]+a[i][j],step[i-1][j]+a[i][j]} 
		注意转移是有环的，要迭代 
	  消除后效性：
		后效性的出现是因为可以同行之间走，但是不会走重复的点是可以肯定的，于是想到后效性是可以消除的。
		现在先考虑同行的情况。
		假设某一时刻走到了 (i,j) 这一点，在下一步决策的时候，要么是(i,j-1)，要么是(i,j+1)，先不考虑加减之后越界的情况。而如果选择了(i,j-1)这个点，下一步再决策的时候，势必不会再重复(i,j)，而只会考虑(i,j-2)。状态d[i][j]定义为从(n,1)到点(i,j)的最短距离大小，若d[i][j]来自同行某个数，只能来自d[i][j-1]或d[i][j+1]其中一个。
		于是有了一个基本的思路：
		对于每一行来说先向右递推，再向左递推，递推式为d[i][j]=min (d[i][j],d[i-1][j]+a[i][j])
		向左推的递推式类似地可以写出。
		每行左右递推各一次即可，环的问题根本不需要担心。d[i][j]必来自于左推和右推时更优的一条路，若将d[i][j][0]定义为表示右推的结果，d[i][j][1]表示左推的结果，则d[i][j]的最终值为min(d[i][j][0],d[i][j][1])，这样可能更好理解一点，说明左右互不影响，只是从中选择一个即可。
		循环进入上一行之后，开始递推向上走的情况，和数字三角形递推式一样，不过边缘需要单独考虑，不再给出
		  d[i][j]=min(d[i+1][j],d[i+1][j+1])+a[i][j] 
*/
#include<cstdio>
const int MAXN=1000,INF=0x3f3f3f3f,dx[4]={-1,-1,0,0},dy[4]={0,-1,-1,1};
int a[MAXN+3][MAXN+3],step[MAXN+3][MAXN+3];
int main(){
	int n,i,j,flag=0;
	scanf("%d",&n);
	for (i=1;i<=n;i++){
		for(j=1;j<=i;j++){
			scanf("%d",&a[i][j]);
			step[i][j]=INF;
		}
	}
	step[1][0]=a[1][1];
	step[1][2]=a[1][1];
	for (i=2;i<=n;i++){
		flag=0;
		while(!flag){	
			step[i][0]=step[i][i];
			step[i][i+1]=step[i][1];
			flag=1;
			for (j=1;j<=i;j++){
				for(int k=0;k<4;k++){
					int p=i+dx[k],q=j+dy[k];
					if(step[i][j]>step[p][q]+a[i][j]){
						step[i][j]=step[p][q]+a[i][j];flag=0;
					}
				}
			}
		}
	}
	printf("%ld",step[n][1]);
	return 0;
}
